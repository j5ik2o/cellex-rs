# 関連型ファクトリ採用に関する検討ノート（2025-10-22）

## 計画の概要

- 既に `ActorRuntime` では関連型 `SyncMutex<T>` / `AsyncMutex<T>` を通じてロック実装を静的切り替えする仕組みが導入済み。
- 次のステップとして、共有ハンドル（`ArcShared`／`RcShared`／埋め込み向けの state cell など）も同じ戦略で統一できるかを検討している。
- 本ノートでは、関連型ファクトリを広げる妥当性を肯定・懐疑の両面から評価し、今後の判断材料を提供する。

## 背景

- ランタイムごとに `Mutex` や共有ハンドルの実装を切り替えたい要求が継続的に存在する。
- 直近の実装では `ActorRuntime` に関連型 `SyncMutex<T>` / `AsyncMutex<T>` を追加し、コンパイル時に適切な実装へ静的バインドする方式を採用した。
- Shared 抽象（`ArcShared`／`RcShared`／`ArcStateCell` 等）にも同様の戦略を拡張できるか議論が生じたため、懐疑的観点で整理しておく。

## 目的の明確化

関連型ファクトリの採用を検討する際には、次の設問へ明示的に答える必要がある。

1. **どの対象を差し替えたいのか？** 例: `SpinSyncMutex` と `StdSyncMutex` の切り替え。
2. **切り替えタイミングはいつか？** 例: ビルド時に cfg で固定するのか、実行時に変更したいのか。
3. **既存実装が抱える痛点は何か？** 例: Tokio でのスピンロックによる CPU バーン。
4. **関連型に拡張することで追加されるコストは何か？** 例: API シグネチャの肥大化やテストマトリクスの拡張。

この問いに対する回答が曖昧なまま抽象を増やすと、保守負担のみが増えるため注意する。

## 懐疑的観点からの論点整理

- **実行時切り替えは現実的でない**
  - Rust では型がコンパイル時に確定するため、`Mutex` や `Arc`/`Rc` を実行時に差し替えるのはほぼ不可能。
  - 実装を動的に交換したい場合、トレイトオブジェクト経由のディスパッチや内部 enum で包む必要があり、ロックのたびに間接参照が入る。
  - 結果としてパフォーマンス低下と API 複雑化が避けられない。

- **静的切り替えなら関連型は有効**
  - `ActorRuntime` の関連型はゼロコストで分岐でき、Tokio/標準/no_std を単一 API で扱える。
  - 実行時要求ではなく「ビルド構成ごとに最適実装を選ぶ」目的に限定するなら、関連型の採用は理にかなっている。

- **Shared 抽象への拡張は影響が大きい**
  - `ArcShared` を返す API が多数存在するため、`type Shared<T>` を導入すると署名変更が広範囲へ波及する。
  - Shared 系は `Arc`/`Rc`/`ArcStateCell` でサポート API が異なる。共通分母だけをトレイト化すると機能が出しづらく、個別最適を失う恐れがある。
  - `SharedBound` による `Send + Sync` 条件の切り替えも絡み、境界設計を誤ると型安全性が下がる。

- **テスト・ドキュメント負荷**
  - 抽象を追加するたびにクロスビルド・単体テストのマトリクスが増え、CI 時間とレビューコストが上がる。
  - 設計ドキュメントやチュートリアルの更新も必要になるため、導入効果が負担を上回るかを測るべき。

## 肯定的観点からの評価

- **ゼロコストで環境差異を吸収**
  - 関連型により、Tokio/標準/no_std などターゲットごとの差異をコンパイル時に解決でき、実行時オーバーヘッドを発生させない。
  - `Props::new` 等の呼び出し側は `AR::SyncMutex::new` と記述するだけで環境依存を意識せず済み、API が簡潔に保てる。

- **静的保証による安全性確保**
  - ロックや共有ラッパーのガード型を関連型で表現することで、`.await` の可否や `Send + Sync` 条件をコンパイル時にチェックできる。
  - `clippy::await_holding_lock` などの lint と組み合わせれば、環境別に異なる落とし穴を静的に防ぎやすい。

- **拡張・差し替えが型レベルで完結**
  - 新しい実装（例: `parking_lot` ベース、embassy 向けラッパー）を追加する際、既存コードをほぼ変更せず関連型の割り当てを差し替えるだけで導入できる。
  - これにより試験的な実装を追加・削除する際の diff が小さく、レビュー負荷も比較的軽微で済む。

- **no_std / 組み込みターゲットへの適合が容易**
  - `target_has_atomic` の有無による `Arc`/`Rc` 切り替えなど、環境制約に応じた実装を一元的に扱える。
  - Shared 抽象も関連型で統一すれば、今後の `Rc` フォールバックや `ArcStateCell` 差し替えを一貫した仕組みで扱える可能性がある。

## 判断指針

1. **痛点の具体化を最優先**
   - 既存 API で解消できない問題が明確に存在するか確認する。
   - Shared 抽象の場合は「Rc バックエンドが必要」「embassy のセルを切り替えたい」などユースケースを列挙する。

2. **静的切り替えへの集中**
   - 実行時 DI を目指さず、ビルド構成による最適化に専念する。
   - その場合は関連型もしくは型パラメータで十分なことが多い。

3. **段階的導入の検討**
   - まず PoC として小さな領域（例: `ArcShared` と `RcShared` のみ）で `SharedLike` トレイトを導入し、影響範囲とテストコストを評価する。
   - 問題がなければ他モジュールへ拡張、難しければ撤退する。

4. **ドキュメント更新のセット運用**
   - 抽象追加時は設計メモ／ガイド／README の更新を同時に行い、利用者が変更を追跡しやすい状態を維持する。

## まとめ

- `Mutex` のように「ビルド時に最適実装を選べれば十分」なケースでは、関連型ファクトリは妥当であり今後も活用できる。
- Shared 抽象へ広げる場合は、関連型による静的保証と差し替え効率のメリットが得られる一方で、API 変更やテスト負荷増大のリスクも同時に抱える。
- Shared 抽象へ拡張する場合は、痛点の鮮明化と影響範囲の見極めが必須。関連型が正解とは限らず、小規模 PoC で効果とコストを天秤にかけるべき。
- 実行時差し替えは Rust では実質的に困難であり、これを追求すると設計が複雑化する。静的最適化に焦点を合わせるのが現実解である。
- 現時点では、Shared 系で複数実装を同一責務として切り替える要求は顕在化していない（`ArcShared` と `RcShared` は用途が異なる）。そのため、無理に関連型ファクトリを導入する必要はなく、現行構成のままで問題ない。
