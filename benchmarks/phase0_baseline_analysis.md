# Phase 0 Baseline Performance Analysis

**測定日**: 2025-10-22
**コミット**: refactor/actor-scheduler branch (Phase 0完了時点)
**実装**: DefaultReadyQueueCoordinator (VecDeque + HashSet + Mutex)

## Executive Summary

現在の実装は**極めて高速**なパフォーマンスを示しており、以下の特徴があります：

- **レイテンシ**: register_ready操作は約30ns（ナノ秒）
- **スループット**: 一貫して24-25 Melem/s（メガ要素/秒）
- **線形スケーリング**: キューサイズに関わらず一貫したパフォーマンス
- **主なボトルネック**: 並行アクセス時のMutexコンテンション（8スレッドで13ms）

**重要な知見**: DashSet/SegQueueへの移行は、並行性が重要なワークロードでのみ価値があると考えられます。

---

## 1. Throughput Benchmarks (mailbox_throughput.rs)

### 1.1 基本スループット (coordinator_throughput)

| 要素数 | 時間 | スループット | 観察 |
|--------|------|-------------|------|
| 100 | 4.01 µs | 24.9 Melem/s | ベースライン |
| 1,000 | 39.4 µs | 25.4 Melem/s | **最高値** |
| 10,000 | 406 µs | 24.6 Melem/s | 一貫性 |
| 100,000 | 4.15 ms | 24.1 Melem/s | わずかな低下（-3.1%） |

**分析**:
- O(1)に近い操作（VecDeque append + HashSet insert）
- 100,000要素でもスループットの低下は最小限（-3.1%）
- 線形スケーリングが確認された

### 1.2 重複検出オーバーヘッド (duplicate_detection)

| 重複率 | 時間 | 要素数 (unique) | 観察 |
|--------|------|----------------|------|
| 0% | 403.57 µs | 10,000 | ベースライン |
| 25% | 329.64 µs | 7,500 | -18.3% |
| 50% | 245.04 µs | 5,000 | -39.3% |
| 75% | 165.23 µs | 2,500 | -59.1% |

**分析**:
- HashSetによる重複検出は非常に効率的
- 重複が多いほど処理時間が短縮される（登録スキップのため）
- 重複検出のオーバーヘッドはほぼゼロ（後述のlatency測定で8ns）

### 1.3 バッチサイズの影響 (batch_size_impact)

| バッチサイズ | 時間 | 観察 |
|------------|------|------|
| 1 | 461.73 µs | ワーストケース（+14%） |
| 10 | 406.59 µs | 良好 |
| 32 | 408.28 µs | 標準 |
| 64 | 405.01 µs | 最適 |
| 128 | 406.88 µs | 一貫 |
| 256 | 408.62 µs | 一貫 |
| 512 | 403.72 µs | **最速** |

**分析**:
- バッチサイズ10以上で安定したパフォーマンス
- バッチサイズ1は+14%のオーバーヘッド（ループオーバーヘッド）
- 推奨バッチサイズ: 32-128（現在の実装と一致）

### 1.4 並行登録スケーラビリティ (concurrent_register)

| スレッド数 | 時間 | スレッドあたり | スケーラビリティ |
|----------|------|---------------|----------------|
| 1 | 472.75 µs | 472.75 µs | ベースライン (1.0x) |
| 2 | 1.1431 ms | 571.55 µs | 0.83x |
| 4 | 4.0887 ms | 1,022 µs | 0.46x |
| 8 | 13.214 ms | 1,652 µs | 0.29x |

**分析**:
- **Mutexコンテンションが顕著**
- 8スレッドで理想値の3.5倍遅い（理想: 3.8ms、実測: 13.2ms）
- **これが主要なボトルネック** - lock-free実装の主な動機

### 1.5 InvokeResult処理オーバーヘッド (invoke_result_handling)

| 結果タイプ | 時間 | 観察 |
|-----------|------|------|
| Completed {ready: true} | 50.83 µs | 再登録あり |
| Completed {ready: false} | 49.40 µs | **最速** |
| Yielded | 50.70 µs | 一貫 |
| Stopped | 49.61 µs | 低速 |

**分析**:
- すべての結果タイプで一貫したパフォーマンス（49-51µs）
- 1,000要素あたり約50ns/要素
- 結果処理タイプによる有意な差はない

### 1.6 Unregister性能 (unregister_performance)

| 要素数 | 時間 | 要素あたり |
|--------|------|-----------|
| 100 | 4.71 µs | 94.2 ns |
| 1,000 | 41.33 µs | 82.7 ns |
| 10,000 | 436.57 µs | 87.3 µs |

**分析**:
- HashSet::remove操作は約85ns（一貫）
- VecDequeからの削除は線形時間だが、実際のアプリケーションでは稀
- Unregisterはクリティカルパスではない

---

## 2. Latency Benchmarks (scheduler_latency.rs)

### 2.1 register_ready操作レイテンシ

| シナリオ | レイテンシ | 観察 |
|---------|----------|------|
| 空キュー | 30.8 ns | ベースライン |
| キューサイズ100 | 30.9 ns | 変化なし |
| キューサイズ1000 | 29.5 ns | **最速** |
| 重複登録 | 8.2 ns | HashSetルックアップのみ |

**分析**:
- **30ナノ秒は極めて高速**（CPUサイクル約120回@4GHz）
- キューサイズによる影響はゼロ（O(1)操作の証明）
- 重複検出は8nsのみ（HashSet::containsの速度）

### 2.2 drain_ready_cycle操作レイテンシ

キューサイズ10の場合：

| バッチサイズ | レイテンシ |
|------------|-----------|
| 10 | 205.85 ns |
| 32 | 209.61 ns |
| 100 | 256.71 ns |

キューサイズ100の場合：

| バッチサイズ | レイテンシ |
|------------|-----------|
| 10 | 301.30 ns |
| 32 | 698.05 ns |
| 100 | 1.90 µs |

キューサイズ1,000の場合（高分散）：

| バッチサイズ | レイテンシ |
|------------|-----------|
| 10 | 537.91 ns |
| 32 | 988.53 ns |
| 100 | 1.98 µs |

キューサイズ10,000の場合（高分散）：

| バッチサイズ | レイテンシ |
|------------|-----------|
| 10 | 7.97 µs |
| 32 | 2.25 µs |
| 100 | 6.44 µs |

**分析**:
- キューサイズが大きいと分散が増加（VecDequeのメモリレイアウト影響か）
- バッチサイズ10-32が最適
- 小規模キュー（<100）では200-700ns程度

### 2.3 handle_invoke_result操作レイテンシ

| 結果タイプ | レイテンシ | 観察 |
|-----------|----------|------|
| Completed {ready: true} | 9.60 ns | 再登録あり |
| Completed {ready: false} | 9.10 ns | **最速** |
| Yielded | 10.01 ns | わずかに遅い |
| Stopped | 8.74 ns | クリーンアップ |

**分析**:
- **9-10ナノ秒は驚異的に高速**
- すべての結果タイプで一貫（±0.5ns）
- 条件分岐のオーバーヘッドはほぼゼロ

### 2.4 unregister操作レイテンシ

| キューサイズ | レイテンシ |
|------------|-----------|
| 10 | 81.33 ns |
| 100 | 120.92 ns |
| 1,000 | 325.56 ns |

**分析**:
- キューサイズに応じて増加（HashSet::removeの複雑さ）
- 1,000要素でも325nsと高速
- アクター停止時のみ使用されるため、クリティカルパスではない

### 2.5 エンドツーエンドレイテンシ (register → drain → handle)

| アイテム数 | レイテンシ | アイテムあたり |
|----------|----------|--------------|
| 1 | 115.27 ns | 115 ns |
| 10 | 561.67 ns | 56 ns |
| 100 | 6.01 µs | 60 ns |

**分析**:
- **完全サイクルでも60ns/アイテム**
- 線形スケーリング（R²=0.99）
- 実際のアクター実行時間（数マイクロ秒以上）と比較して無視できるオーバーヘッド

### 2.6 レイテンシパーセンタイル (100アイテムのregister+drain)

測定: 1,000サンプル、4.04 µs平均

**期待される分布（Criterionレポートより）**:
- p50 (中央値): ~4.02 µs
- p95: ~4.10 µs
- p99: ~4.20 µs
- p99.9: ~4.40 µs（推定）

**分析**:
- 非常に低い分散（89/1000サンプルがoutlier）
- 予測可能なパフォーマンス
- テールレイテンシも許容範囲

### 2.7 ワーストケースレイテンシ

| シナリオ | レイテンシ | 観察 |
|---------|----------|------|
| 大量の重複 (1000回登録) | 7.97 µs | HashSetが効果的に機能 |
| Interleaved register/drain | 2.65 µs | 問題なし |

**分析**:
- ワーストケースでも10µs以下
- システムは病的なケースに対しても堅牢

---

## 3. Performance Characteristics Summary

### 3.1 強み

1. **極めて低いレイテンシ**
   - register_ready: 30ns
   - handle_invoke_result: 9ns
   - End-to-end: 60ns/item

2. **線形スケーリング**
   - キューサイズに関わらず一貫したスループット（24-25 Melem/s）
   - 100,000要素でもパフォーマンス低下は最小限

3. **効率的な重複検出**
   - HashSetによる重複チェックは8nsのみ
   - 重複が多い場合は処理時間が短縮される

4. **予測可能なパフォーマンス**
   - 低い分散、安定したパーセンタイル
   - ワーストケースでも10µs以下

### 3.2 弱み

1. **並行性のボトルネック**
   - Mutexコンテンションが顕著
   - 8スレッドで理想値の3.5倍遅い
   - スケーラビリティ: 8スレッドで0.29x

2. **VecDequeのメモリレイアウト**
   - 大きなキューサイズでdrain操作の分散が増加
   - キャッシュミス率が影響している可能性

### 3.3 アクターシステムのコンテキストでの評価

**実際のアクター実行時間**:
- 最小のアクター処理: ~1-10 µs（シンプルな状態更新）
- 典型的な処理: ~10-100 µs（ビジネスロジック）
- I/O処理: ~100 µs - 数ms

**スケジューラーオーバーヘッド比率**:
- 最小処理 (1 µs): 6% (60ns / 1000ns)
- 典型処理 (10 µs): 0.6% (60ns / 10000ns)
- I/O処理 (100 µs): 0.06% (60ns / 100000ns)

**結論**: 現在の実装は、ほとんどのアクターワークロードにおいて**無視できるオーバーヘッド**です。

---

## 4. Phase 1実装方針の推奨事項

### 4.1 DashSet/SegQueueへの移行判断

**移行が必要なケース**:
1. **高並行アプリケーション** (8+スレッド)
2. **短命なアクター** (処理時間<10µs)
3. **低レイテンシが重要** (リアルタイムシステム)

**移行が不要なケース**:
1. **単一スレッド/低並行** (1-4スレッド)
2. **I/Oバウンドアクター** (処理時間>100µs)
3. **スループット重視** (レイテンシ要件が緩い)

### 4.2 推奨アプローチ

#### オプションA: 条件付き実装（推奨）

```rust
pub enum ReadyQueueImpl {
    /// 低並行、安定性重視
    Locked(LockedCoordinator),

    /// 高並行、パフォーマンス重視
    LockFree(LockFreeCoordinator),
}

impl ReadyQueueCoordinator {
    pub fn new(concurrency_hint: usize) -> Self {
        if concurrency_hint <= 4 {
            Self::Locked(LockedCoordinator::new())
        } else {
            Self::LockFree(LockFreeCoordinator::new())
        }
    }
}
```

**利点**:
- 両方の実装の長所を活用
- ワークロードに応じた最適化
- 段階的な移行が可能

#### オプションB: 測定後の全面移行

1. lock-free実装を完成させる
2. 同じベンチマークで測定
3. すべてのシナリオで改善が確認されたら移行
4. 改善が限定的な場合は条件付き実装に戻る

#### オプションC: 現状維持（保守的）

- **30ns/60nsのレイテンシは既に十分高速**
- 並行性が問題になるまで最適化を延期
- YAGNI原則の適用

### 4.3 最終推奨

**条件付き実装（オプションA）を推奨します**:

**理由**:
1. 現在の実装は単純で保守性が高い
2. 並行性のボトルネックは実測されている
3. lock-free実装は複雑さを増すが、限定的なケースで価値がある
4. 両方の実装を保持することで、ユーザーが選択できる

**実装フェーズ**:
- **Phase 1 Week 2**: DashSet/SegQueueベースのLockFreeCoordinator実装
- **Phase 1 Week 3**: 両実装のベンチマーク比較と検証
- **Phase 1 Week 4**: 条件付きコンストラクタと統合テスト

---

## 5. 追加の最適化機会

### 5.1 短期的改善（Phase 1内）

1. **バッチサイズの動的調整**
   - 現在: 固定32
   - 提案: キューサイズに応じて10-128に調整

2. **VecDequeのプリアロケーション**
   - with_capacity()の使用を徹底
   - 再割り当てのオーバーヘッドを削減

### 5.2 中期的改善（Phase 2-3）

1. **スレッドローカルキャッシュ**
   - register_ready操作をローカルバッファに蓄積
   - 定期的にグローバルキューにフラッシュ
   - Mutexコンテンションを削減

2. **Work Stealing**
   - 各ワーカースレッドが独自のキューを持つ
   - アイドルスレッドが他のキューから盗む
   - Golang/Tokioのアプローチ

---

## 6. Appendix: ベンチマーク環境

- **CPU**: Apple Silicon (M1/M2/M3推定)
- **OS**: macOS 14.x (Darwin 24.5.0)
- **Rust**: 2021 edition
- **最適化**: --release (opt-level=3)
- **測定ツール**: Criterion 0.5.x

---

## 7. Conclusion

現在のDefaultReadyQueueCoordinator実装は：

✅ **極めて高速** - 30nsレイテンシ、24-25 Melem/sスループット
✅ **線形スケーリング** - キューサイズに関わらず一貫
✅ **予測可能** - 低い分散、安定したパーセンタイル
⚠️ **並行性に制限** - Mutexコンテンションが8スレッドで顕著

**Phase 1の方針**: 条件付きlock-free実装を推奨します。現在の実装の保守性を維持しつつ、高並行ワークロードでのパフォーマンスを改善します。

**Next Steps**:
1. Phase 1 Week 2: LockFreeCoordinator実装開始
2. Phase 1 Week 3: 両実装のベンチマーク比較
3. Phase 1 Week 4: 条件付き選択メカニズムの実装と検証
